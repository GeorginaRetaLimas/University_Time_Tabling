ESPECIFICACIONES TÉCNICAS DEL SISTEMA DE HORARIOS UTP
=====================================================

1. ARQUITECTURA DEL SISTEMA
---------------------------
El sistema utiliza una arquitectura híbrida de alto rendimiento:
- Frontend: HTML5, CSS3 (Diseño responsivo, tema "Purple"), JavaScript (Vanilla) para la lógica de interfaz.
- Backend: Python 3.12 con Flask para la API REST y gestión de archivos.
- Núcleo de Procesamiento (Solver): C++17 para la ejecución intensiva del algoritmo de horarios.
- Capa de Integración: Cython para la comunicación directa y eficiente entre Python y C++.

2. LÓGICA Y ALGORITMO
---------------------
El núcleo del sistema ("TimetableSolver") implementa un algoritmo de satisfacción de restricciones (CSP) personalizado:

A. Algoritmo Principal: Búsqueda por Retroceso (Backtracking)
   - El sistema explora el espacio de soluciones asignando recursos (profesor, horario) a cada sesión de clase secuencialmente.
   - Si encuentra un conflicto, "retrocede" (backtracks) a la decisión anterior y prueba una opción diferente.

B. Heurísticas de Optimización
   - Ordenamiento por Dificultad (Difficulty Sorting): Antes de iniciar, las sesiones se ordenan bajo dos criterios:
     1. Carga Horaria (Descendente): Las materias con más horas semanales se asignan primero, ya que son más difíciles de acomodar.
     2. ID de Grupo: Para mantener cohesión en la exploración.
   - Grafo de Conflictos: Se pre-calcula una matriz de adyacencia para detectar conflictos en tiempo constante O(1) durante la exploración.

C. Estrategia "Best-Effort" con Tiempo Límite
   - El algoritmo acepta un parámetro de `timeout` (ej. 60 segundos).
   - Si el tiempo se agota antes de encontrar una solución perfecta completa, el sistema detiene la ejecución y devuelve la "Mejor Solución Parcial" encontrada hasta el momento.
   - Esto garantiza que el usuario siempre obtenga un resultado, incluso en escenarios de alta complejidad.

3. RESTRICCIONES DEL SISTEMA 
----------------------------
El solver garantiza el cumplimiento de las siguientes reglas:

A. Restricciones Duras (Hard Constraints) - Inviolables
   1. Unicidad del Profesor: Un profesor no puede impartir dos clases simultáneamente.
   2. Unicidad del Grupo: Un grupo de alumnos no puede tener dos materias asignadas en el mismo horario.
   3. Disponibilidad: Las clases solo se asignan en bloques de tiempo donde el profesor ha marcado explícitamente su disponibilidad.

B. Manejo de Excepciones
   - Materias sin Profesor (ej. "Estadía", "Inglés" en ciertos casos): El sistema permite asignar materias sin un profesor específico (ID=0). En estos casos, se ignoran las restricciones de profesor pero se mantienen estrictamente las restricciones de grupo.

4. DETALLES DEL PROGRAMA Y FLUJO DE DATOS
-----------------------------------------
1. Entrada de Datos:
   - Los datos se cargan desde archivos CSV (Cursos) y JSON (Profesores, Horarios).
   - El Frontend permite seleccionar el "Periodo Académico" (ej. Enero-Abril), filtrando los cuatrimestres activos.

2. Procesamiento:
   - Python transforma los datos crudos en estructuras vectoriales optimizadas.
   - C++ recibe los vectores y ejecuta el algoritmo `solve()`.
   - Se utiliza `std::chrono` para el control preciso del tiempo de ejecución.
   - Se implementa manejo de excepciones (try-catch) para evitar caídas del servidor ante datos corruptos.

3. Salida y Visualización:
   - El resultado se devuelve como un objeto JSON con las asignaciones.
   - El Frontend enriquece los datos (uniendo IDs con Nombres) y renderiza una cuadrícula semanal ("Grid") agrupada por Cuatrimestre.
   - Se incluye un modal de carga para mejorar la experiencia de usuario durante el procesamiento.
